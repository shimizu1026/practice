💡 コードの解説
このコードのポイントは、<details> 要素のアニメーションです。

アニメーションの仕組み:

通常、<details> 要素の開閉はアニメーションできませんが、このコードでは display: grid と grid-template-rows を使って、高さを「0fr (ゼロ)」から「1fr (中身の分)」へ変化させています。

transition-property: grid-template-rows; を指定することで、この 0fr から 1fr への変化が 300ms（--_duration の値）かけてスムーズに行われ、アコーディオンが開くようなアニメーションが実現できています。

::details-content:

これは「<details> の中身（<summary> タグ以外の部分）」だけを選択できる、比較的新しいCSSの機能（疑似要素）です。

このおかげで、開閉するコンテンツ部分（.content-wrapper）に直接アニメーションのスタイルを当てることができます。

& とネスト (CSS Nesting):

元のコードにあった &::details-content や &:hover の & は、「親のセレクタ（details や summary）自身」を指します。

details { &:not([open]) { ... } } は、details:not([open]) { ... } と同じ意味になります。

これはSASS/SCSSで使われていた便利な書き方ですが、最近のブラウザでは「普通のCSS」としてサポートされるようになりました。

oklch() と相対色構文:

oklch(from var(--_background-default) calc(l - 0.1) c h) は、「--_background-default（元の赤色）を基準にして、輝度(l)だけを 0.1 下げる」という指定です。

これにより、:hover した時に「元の色より少し暗い色」を簡単に作ることができています。これも非常に新しいCSSの機能です。

フォントサイズを画面幅（ブラウザの幅）に応じて自動的に拡大・縮小させつつ、「最小サイズ」と「最大サイズ」の範囲内に収めるための、非常に便利なCSSの記述です。

*******************************************

font-size: clamp(0.75rem, 0.705rem + 0.23svi, 0.875rem);について
1. clamp() 関数とは？
clamp() は「挟む」という意味の英単語 "clamp" から来ています。 その名の通り、最小値、推奨値、最大値 の3つを指定して、値を一定の範囲内に「挟み込む」関数です。

基本の形: clamp(最小値, 推奨値, 最大値);

動作の仕組み:

ブラウザはまず 推奨値 を使おうとします。

もし 推奨値 の計算結果が 最小値 よりも小さくなってしまったら、代わりに 最小値 を使います。

もし 推奨値 の計算結果が 最大値 よりも大きくなってしまったら、代わりに 最大値 を使います。

2. svi 単位とは？
svi は、比較的新しい「ビューポート単位」の一つです。

vi (Viewport Inline):

ブラウザの表示領域の**インライン方向（横書きの場合は「幅」）**のサイズに基づきます。

1vi = ビューポートの幅の 1% です。（1vw とほぼ同じ意味です）

s (Small):

s が付くと「スモールビューポート」を意味します。

これは、スマートフォンのブラウザでアドレスバーや下のツールバーなどが表示されている状態（つまり、Webページが見える領域が一番小さい状態）のサイズを基準にします。

0.23svi とは:

つまり「（ツールバー表示時の）ブラウザの幅の 0.23%」という意味になります。

3. コード全体の解説
これを踏まえて、ご提示のコードを見てみましょう。

font-size: clamp(0.75rem, 0.705rem + 0.23svi, 0.875rem);

これは、ブラウザに対して以下のように指示しています。

最小値 (MIN): 0.75rem

計算結果がどれだけ小さくなっても、フォントサイズは絶対に 0.75rem（約12px）より小さくしないでください。

最大値 (MAX): 0.875rem

計算結果がどれだけ大きくなっても、フォントサイズは絶対に 0.875rem（約14px）より大きくしないでください。

推奨値 (VAL): 0.705rem + 0.23svi

基本的には、0.705rem（固定の基本サイズ）に「画面幅の 0.23%」を足したサイズを使ってください。

📈 実際の動作イメージ
画面幅がとても狭い時 (例: スマートフォン): 0.705rem + 0.23svi の計算結果が 0.75rem を下回ります。すると clamp() が働き、0.75rem が採用されます（最小値）。

画面幅が中くらいの時 (例: タブレット): 0.705rem + 0.23svi の計算結果が 0.75rem と 0.875rem の間に収まります。この場合は、その計算結果がそのまま採用されます。画面幅が広がるにつれて、フォントも滑らかに大きくなります。

画面幅がとても広い時 (例: PC): 0.705rem + 0.23svi の計算結果が 0.875rem を超えます。すると clamp() が働き、0.875rem が採用されます（最大値）。

このように、clamp() を使うことで、CSS（メディアクエリ）で「画面幅が〇〇px以上の時は...」といった指定を細かく書かなくても、一行で滑らかに変化するレスポンシブなフォントサイズを実現できます。

パターンA: 常に 16px（固定サイズ）にしたい場合
もし「画面幅がスマホでもPCでも、常に 16px にしたい」というデザインなら、clamp() を使う必要はありません。

これが一番シンプルです。

CSS

/* 常に 16px (1rem) にする場合 */
font-size: 1rem; 
px を使って font-size: 16px; と書くこともできますが、rem を使っておくと、ユーザーがブラウザで「文字を大きくする」設定をしていた場合に対応できるため、rem の方が好まれることが多いです。

🎨 パターンB: 16px を基準に可変（レスポンシブ）にしたい場合
「PCなどの広い画面では 16px だけど、スマートフォンではもう少し小さくしたい（例えば 14px にしたい）」という意図であれば、まさに clamp() の出番です。

この場合、16px を「最大値」として使います。

記述例（最小 14px 〜 最大 16px）
最小値 (MIN): 0.875rem (計算: 14px ÷ 16px)

最大値 (MAX): 1rem (計算: 16px ÷ 16px)

推奨値 (VAL): 基本サイズ + 可変サイズ (調整が必要)

CSS

/* 最小 14px、最大 16px の間で自動調整する例 */
font-size: clamp(0.875rem, 0.8rem + 0.3svi, 1rem);
推奨値 (0.8rem + 0.3svi) の解説
ここが clamp() の一番難しいところですが、0.8rem や 0.3svi といった数値は「調整する数値」です。

0.8rem (12.8px): フォントサイズの「基本となる部分」です。

0.3svi: 「画面幅の 0.3%」を追加分として足していきます。

動作イメージ:

画面幅が狭い時 (スマホなど)

0.8rem + 0.3svi の計算結果が 0.875rem (14px) よりも小さくなります。

すると clamp() が働き、0.875rem (最小値) が採用されます。

画面幅が広がっていく時

0.3svi の追加分が増えていき、フォントが 0.875rem から 1rem に向かって滑らかに大きくなります。

画面幅が十分に広い時 (PCなど)

0.8rem + 0.3svi の計算結果が 1rem (16px) を超えます。

すると clamp() が働き、1rem (最大値) が採用されます。

この「推奨値」の部分は、clamp(0.875rem, 0.85rem + 0.2svi, 1rem) のように数値を調整して、デザインの意図に合う変化の仕方を実際にブラウザで見ながら探していくのが一般的です。

📏 rem 単位で余白を管理する方法
1. rem の計算を楽にする（calc()の活用）
前回ご紹介した calc() 関数は、余白の計算にもそのまま使えます。デザインカンプ通りの px 値をコードに残せるため、最も管理しやすい方法です。

CSS

/* 例: 16px を基準とする */
:root {
  /* ... */
}

.summary {
  /* デザインカンプで上下 16px、左右 48px だった場合 */
  padding-block: calc(16 / 16 * 1rem); /* 上下: 1rem (16px) */
  padding-inline: calc(48 / 16 * 1rem); /* 左右: 3rem (48px) */
}

.content {
  /* デザインカンプで 24px だった場合 */
  padding: calc(24 / 16 * 1rem); /* 1.5rem (24px) */
}
利点: rem への変換を意識せず、元の px 値を元に余白を設定できます。

2. CSS変数で統一的なスケールを定義する（推奨）
より進んだ管理方法として、余白のサイズを定義したCSS変数（カスタムプロパティ）を作り、それを各所で使い回すのがおすすめです。これにより、デザイン全体に統一感のある余白のスケールを適用できます。

これは「スペーシングスケール」と呼ばれる手法です。

CSS

/* 基準となる余白スケールを :root に定義 */
:root {
  /* S=8px, M=16px, L=24px, XL=32px を想定 */
  --spacing-s: 0.5rem;   /* 8px */
  --spacing-m: 1rem;     /* 16px */
  --spacing-l: 1.5rem;   /* 24px */
  --spacing-xl: 2rem;    /* 32px */
  /* ... さらに細かく定義できます */
}

/* 実際に使用する時 */
.summary {
  /* 上下に M (16px)、左右に L (24px) を適用 */
  padding-block: var(--spacing-m);
  padding-inline: var(--spacing-l);
}

.content {
  /* 全て L (24px) のパディングを適用 */
  padding: var(--spacing-l);
}

.wrapper > *:not(:last-child) {
  /* 要素間に XL (32px) のマージンを適用 */
  margin-bottom: var(--spacing-xl);
}
利点:

統一感: 余白がバラバラにならず、デザインシステムに基づいた統一感のあるレイアウトになります。

変更容易性: スケールを変更したい場合（例: Mサイズを 16px から 20px に変えたい）、:root の定義を一つ変えるだけで、全てのMサイズ余白が更新されます。

可読性: var(--spacing-m) のように、その余白の役割を意識しながらコードを書くことができます。

💡 なぜ余白も rem にするのか？
余白（padding, margin）を rem で指定することには、大きなメリットがあります。

フォントサイズとの連動: ユーザーがブラウザの設定でフォントサイズを変更した場合、rem 単位の余白もフォントサイズに合わせて拡大・縮小されます。これにより、文字が大きくなったときに余白が詰まりすぎず、レイアウトの崩れを防ぐことができます。

一貫性のあるレスポンシブ: rem は基準サイズ（多くの場合 16px）に依存しているため、サイト全体のサイズ感が統一され、clamp() を使ったフォントサイズの変化にも自然に馴染みます。

****************************************
  @media (prefers-reduced-motion: no-preference) {
    transition-duration: var(--_duration);
    transition-property: grid-template-rows;
  }
  
CSSのメディアクエリ と トランジション（アニメーション） を組み合わせたもので、「アクセシビリティへの配慮」のために使用されます。

💡 コードの解説
1. @media (prefers-reduced-motion: no-preference)
これは メディアクエリ です。ユーザーが設定しているOS（オペレーティングシステム）の環境設定をチェックしています。

prefers-reduced-motion: これは、ユーザーがアニメーションや動きの量を減らしたい、つまり「動きを抑えた表示を好むかどうか」を尋ねる機能です。

no-preference: これは「特に動きを減らすことを希望していない」という設定値です。

意味: 「ユーザーがシステム設定で特にアニメーションを減らす設定をしていない場合に、この中括弧 {} の中のスタイルを適用する」という意味になります。

2. transition-duration: var(--_duration);
これは トランジション（変化）の時間 を設定しています。

transition-duration: スタイルが変化するのにかかる時間を指定します。

var(--_duration): CSS変数で定義された時間（元のコードでは 300ms）が適用されます。

3. transition-property: grid-template-rows;
これは トランジションの対象となるプロパティ を指定しています。

transition-property: どのCSSプロパティの変化にアニメーションを適用するかを指定します。

grid-template-rows: このプロパティの値（アコーディオンの開閉で 0fr から 1fr へ変化する部分）が、transition-duration で指定された時間（300ms）をかけて滑らかに変化するようになります。

📝 なぜこのように書くのか？（アクセシビリティ）
この書き方の一番の目的は、ユーザー体験とアクセシビリティの向上です。

動きの激しいアニメーションは、人によってはめまいや乗り物酔いのような症状（前庭障害など）を引き起こすことがあります。

このメディアクエリを使うことで、ユーザーがPCやスマートフォンのOS設定で「アニメーションを減らす」や「視差効果を減らす」といった設定を有効にしている場合、このアニメーション（トランジション）のコードをスキップできます。

つまり、**動きに敏感なユーザーにはアニメーションなし（瞬時の開閉）**を、アニメーションを好むユーザーにはスムーズな開閉を提供できるようになり、より多くの人が快適にウェブサイトを利用できるようになります。